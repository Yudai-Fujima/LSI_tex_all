\newpage
\section{エミュレータにおける、固定小数点の検討}
本章では、FPGA実装を想定し、固定小数点表現におけるビット幅設計の工夫により、精度を維持しつつビット幅を最小化したエミュレータの構築手法について検討する。

\subsection{カーネル(重み)の固定小数点の検討}
\tref{tab:weight_minmax}に各層のカーネル（重み）の最大値・最小値を示す。\tref{tab:weight_minmax}から、整数部はないことが分かるから、符号部1bit、小数部7bitと考え、int8(Q0.7)で重みの保存を行う。Qa.bは整数部のビット数がa、小数部のビット数はbであることを示す。Q0.7によって表現できる範囲は$-1\sim0.992(1-2^{-7})$であり、分解能は1/128である。この範囲がint8の$-128\sim127$にマッピングされる。具体的に、実数値で0.6046は77.38$\simeq78$（四捨五入）に対応する。以後の計算では、16bitとしてint16を用いるが、重みパラメータはリソースの確保および計算精度を担保できることから8bitで表現した。

\begin{table}[htbp]
\centering
\caption{各層カーネルの最小値・最大値}
\label{tab:weight_minmax}
\begin{tabular}{l l r r}
\hline
Layer & Shape & Min & Max \\
\hline
net0 & $(100, 512, 4, 4)$ & $-0.7249$ & $0.6046$ \\
net1 & $(512, 256, 4, 4)$ & $-0.7105$ & $0.2585$ \\
net2 & $(256, 128, 4, 4)$ & $-0.4607$ & $0.2120$ \\
net3 & $(128, 1, 4, 4)$ & $-0.2351$ & $0.1872$ \\
\hline
\end{tabular}
\end{table}


\subsection{各層の出力に対する固定小数点の検討}
任意のランダム入力に対する、各層の出力(output1～4)の実数値の最大値・最小値を\tref{tab:output_minmax}に示す。\tref{tab:output_minmax}から整数部を6bit持たせると、$-64.000\sim63.998$まで表せるため十分な範囲であるといえる。しかし、今回の値は任意の入力に対するものであるから、頑健性を考慮して、Q7.8(int16)での実装を行った。Q7.8の実数の表現範囲は$-128.000\sim127.996$であり、分解能は1/256である。これをint16の$-32768\sim32767$の範囲にマッピングする。int8(Q0.7)からint16(Q7.8)の変換については、小数部が一桁増加することから、int8の値に$2^1$を掛けることでint16の値を得た。例として、実数値で0.6046はint8で77.38$\simeq78$であり、これに2を掛けると156(int16)である。これを実数値に戻すには、$2^8=256$で割ると0.609となり元の実数値に近い値となることが分かる。

\begin{table}[t]
\centering
\caption{各層出力の最小値・最大値}
\label{tab:output_minmax}
\begin{tabular}{l r r}
\hline
Layer & Min & Max \\
\hline
output0 & $-13.46$ & $12.44$ \\
output2 & $-47.34$ & $20.94$ \\
output3 & $-47.62$ & $14.70$ \\
output4 & $-8.46$  & $11.23$ \\
\hline
\end{tabular}
\end{table}

\subsection{各逆畳み込み演算の乗算における、固定小数点の検討}
前節で示したように、計算時には基本的にint16(Q7.8)が用いられる。しかし、畳み込み演算の際に乗算が含まれるため、Q7.8×Q7.8=Q14.16となりint16の範囲ではオーバーフローしてしまう。そこで、掛け算の結果のみint32(Q14.16)で保存し、計算後の結果に対し$2^8$で割った値をint16(Q7.8)に格納した。実際に、「0.6046×0.6046=0.36554116」の計算を例に挙げると、int16では「155×155=24025」となる。24025の値を小数部16bitをもつ値と考えるとQ7.8の精度に戻すには$2^8$で割る必要がある。よって、「$24025÷256=93.84\simeq94$」となる。int16(Q7.8)で94であるから、これを実数に戻すと「94÷256=0.3671875」であり、実数で計算した値に近い値となることが分かる。


\subsection{tanhテーブルにおける固定小数点の検討}
outpu4の値はtanhを掛けた後、256階調にして画像として表示する。このtanhの入力を16bitにする場合、高精度にはなるがテーブル作成分のメモリ消費が大きくなる。そこで、8bitの入力でtanhテーブルを作成する方法を考えた。

まず、output4の出力は\tref{tab:output_minmax}より、$\pm$10の範囲程度であるから、整数部を5bit、小数部を2bitとしてQ5.2を用いると8bitで表現できることが分かる。Q5.2の範囲は、$-32\sim31.75$で分解能は1/4である。Q7.8からQ5.2に変換するには、int16の値を$2^6$で割ればよい。これによって、ここまでの計算結果をint8(-128～127)の範囲にマッピングできる。

tanhは入力された値を$-1～1$の範囲に非線形変換するが、今回int8を用いるため、$-128～127$の範囲にマッピングするようなtanhテーブルを作成する。int8の入力に対し、int8の出力を返すtanhテーブルをプロットすると\fref{fg:tanh}となる。このtanhの出力に対し、+128を足し合わせることで0～255の256階調となる。今回は演算数を減らす目的で、\fref{fg:tanh}の値に+128を足したものをtanhテーブルとして実装した。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=60mm,keepaspectratio]{figure/tanh.png}
	\caption{tanhテーブル(int8対応)}
	\label{fg:tanh}
\end{figure}

\subsection{固定小数点の検討のまとめ}
以上の内容をまとめた概要図を\fref{fg:matome}に示す。ポイントは、リソース確保のため、重みパラメータをint8で保存したこと。基本的な演算はint16(Q7.8)だが、乗算部分はint32(Q14.16)で確保したこと。tanhテーブルの出力を-128～127ではなく、0～255にすることにより、画像変換までを一気通貫で行うテーブルを作成したことである。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=60mm,keepaspectratio]{figure/kotei.png}
	\caption{固定小数点の検討のまとめ}
	\label{fg:matome}
\end{figure}